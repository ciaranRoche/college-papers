\section{Building an Operator}
\label{sub:practical}

\subsection{Install Operator SDK}
To begin building an Operator it was decided to use the Operator SDK. In order to use the Operator SDK, GO is needed to be installed, and the operator-framework to be added to the GOPATH. Once added clone the Operator SDK, link can be found in Appendix \ref{appendix:opsdk}. With the SDK cloned it is a matter of running \textit{make dep} and \textit{make install}. Just to note after a recent update to osMojave it caused an error with xCode Command Line Tools, the error thrown can be seen in Figure \ref{img:p1}. After a number of trouble shooting steps, to fix this error xcode-select needed to be reset, \textit{xcode-select --reset}.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p1.png}
\caption{\em Xcode error}
\label{img:p1}
\end{figure}

\subsection{Memcached Operator}
For this section of the report we are going to work with the example Memcached Operator supplied with the Operator SDK in order to get a better understanding of what is happening under the hood of an Operator.
\\Memcached is a general-purpose distributed memory caching system. It is often used to speed up dynamic database-driven websites by caching data and objects in RAM. Memcached is free and open sourced \citep{Memcached}. The operator built for this practical can be found at Appendix \ref{appendix:memop}.

\subsection{Initialize Operator}
With the error fixed the dependencies could be added and the Operator SDK installed. With that it can be seen in Figure \ref{img:p2}, creating a new operator, it should be noted following with Go practises the operator was created in \textit{\$GOPATH/src/github.com/ciaranRoche/} directory.
\begin{figure}[!hb]
\centering
\includegraphics*[width=0.8\textwidth]{images/p2.png}
\caption{\em Create a new Operator}
\label{img:p2}
\end{figure}

\newpage
\subsection{Adding Custom Resource Definition}
With a basic Operator created we will need to add a Custom Resource Definition. This can be seen in Figure \ref{img:p3}. We call this Memcached and add it with an APIVersion of \textit{cache.ciaranroche.com/v1apha1}.

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p3.png}
\caption{\em Add Operator API}
\label{img:p3}
\end{figure}

\subsection{Adding a Controller}
\label{sub:addcon}
A new Controller is added and can be seen in Figure \ref{img:p4}, the Controller will watch and reconcile the Memcached resource. This will be discussed further in Section \ref{sub:controller}.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p4.png}
\caption{\em Add Operator Controller}
\label{img:p4}
\end{figure}

\newpage
\subsection{Operator Layout}
Figure \ref{img:p5} shows the folder structure to the Operator that has been created through the Operator SDK. As can be seen from the structure the amount of boilerplate created shows the value of the Operator framework when it comes to creating an Operator.

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p5.png}
\caption{\em Operator Tree}
\label{img:p5}
\end{figure}

The breakdown of Figure \ref{img:p5} is as follows:
\begin{itemize}
    \item \textbf{Gopkg.lock Gopkg.lock :} The Go files that outline any external dependencies for the Operator
    \item \textbf{build :} Contains a Dockefile which is used to build and dockerize the operator
    \item \textbf{cmd :} Contains the manager which is the entry point to initialize and start the operator using the operator-sdk API
    \item \textbf{deploy :} Contains the Kubernetes manifests for the deployment of the Operator on a Kubernetes cluster.
    \item \textbf{pkg :} This defines the APIs and Custom Resource Definitions.
    \item \textbf{vendor :} A GoLang folder that holds local copies to dependencies for the operator
    \item \textbf{version :} Contains version data of the Operator
\end{itemize}

\subsection{Manager}
\label{sub:manager}
The Operator main program within the \textit{cmd/manager/} dirctory, initializes and runs the Manager. Its the Managers job to automatically register the scheme set for all custom resources that are defined under the Operator, and also run all controllers. The manager can restrict the namespaces this can be seen in Figure \ref{img:p6}
\begin{figure}[!ht]
\centering
\includegraphics*[width=0.8\textwidth]{images/p7.png}
\caption{\em Setting CRD's and Controllers}
\label{img:p7}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics*[width=0.8\textwidth]{images/p6.png}
\caption{\em Manager function to restrict the namespace}
\label{img:p6}
\end{figure}

\subsection{Custom Resource Definition}
\label{sub:crd}
From the boilerplate of the CRD that was generated by the command in Figure \ref{img:p3} we need to define our own Custom Resource, this can be seen in Figure \ref{img:p8}, where we define the size of the Memcached deployment along with the nodes being the name of the Memcached pods.
\begin{figure}[!hb]
\centering
\includegraphics*[width=0.7\textwidth]{images/p8.png}
\caption{\em Memcache CRD }
\label{img:p8}
\end{figure}

It should be noted that it is needed to generate the code for the resource which we just defined that can be done by executing the \textit{generates k8s} command, which can be seen in Figure \ref{img:p9}
\begin{figure}[!hb]
\centering
\includegraphics*[width=1\textwidth]{images/p9.png}
\caption{\em Generate k8s}
\label{img:p9}
\end{figure}

\subsection{Controller}
\label{sub:controller}
A powerful aspect to operators is their \textit{watch} function. In that is watches for events to happen and on the event happening the watch will trigger and act. 
\\When we added the controller to our operator in Section \ref{sub:addcon} it scaffold a new Controller implementation for us in the \textit{pkg/controller/memcached} directory. From this implementation we can see how the Controller watches resources and how it triggers the reconcile loop.
If we refer to Figure \ref{img:p10} we can see two watch functions that were generated for us. The first watch function is for the Memcached type as the primary resource. For every event the reconcile loop is sent a reconcile request for the Memcached object. A reconcile request is made up of a namespace/name key.
\\If we look at the second watch function this is for Deployments. The event handler here maps each event to a reconcile request. Which in Figure \ref{img:p10} is the Memcached object for which the Deployment was created. This allows the controller to watch Deployments as a secondary resource.
\begin{figure}[!hb]
\centering
\includegraphics*[width=1\textwidth]{images/p10.png}
\caption{\em Controller watch functions.}
\label{img:p10}
\end{figure}
\\Every Controller has a Reconciler object that contains a reconcile function which implements the reconcile loop. The loop is passed the reconcile request which I mention earlier contains a Namespace/Name Key, this is used to lookup the primary resource object. Figure \ref{img:p11} shows the reconcile function which was generated for us. Based on the result from this function the request may be requeued and then the loop triggered again.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p11.png}
\caption{\em Controller reconcile function.}
\label{img:p11}
\end{figure}


\subsection{Building the Operator}
\label{sub:buildop}
Before building and running the Operator we need to register our Custom Resource Definition with the Kubernetes apiserver. This can be seen in Figure \ref{img:p12}. It should be noted when I first ran this command, I was running on Minishift, which is a tool to allow you to run an OKD cluster locally. OKD is the community edition of OpenShift. OpenShift is classed as enterprise Kubernetes. Due to the way OKD hands users I was unable to create a CRD and need to log in as an admin. To avoid running into any other problems, I shutted down Minishift and started up Minikube and ran Kubernetes locally through that.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p12.png}
\caption{\em Registering CRD}
\label{img:p12}
\end{figure}
\\Once we have registered the CRD, Figure \ref{img:p13} and \ref{img:p14} shows how to build an operator image using the operator sdk. As can be seen we then use Docker to push the image to Quay.io
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p13.png}
\caption{\em Building Operator Image}
\label{img:p13}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/p14.png}
\caption{\em Pushing Image to Quay.io}
\label{img:p14}
\end{figure}
It should be noted here to check your Quay.io repository to ensure the image is set to public visibility to avoid and unwanted behaviour later on.

Now with the image pushed to the repository we need to update our \textit{Operator.yaml} file in order to reflect the current image which we have stored in our repo. The \textit{Operator.yaml} file can be seen in Figure \ref{img:opp01}.

\begin{figure}[!ht]
\centering
\includegraphics*[width=0.8\textwidth]{images/opp01.png}
\caption{\em Operator.yaml (Note: Some of the file has been left out}
\label{img:opp01}
\end{figure}

With the \textit{Operator.yaml} file updated we can begin running our Operator. The commands used are the same as those used in Section \ref{sub:etcd} with the etcd Operator. 
First we make sure the Custom Resource Definition is registered with the Kubernetes apiserver this can be seen in Figure \ref{img:op_2}
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/op02.png}
\caption{\em Registering the CRD}
\label{img:op02}
\end{figure}

Next we need to set up the Kubernetes Role Based Access Control, this can be seen in Figure \ref{img:op03}.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/op03.png}
\caption{\em Setup RBAC}
\label{img:op03}
\end{figure}

If we run the \textit{get deployment} command we can see we have created our operator and have it running within our Kubernetes cluster. This can be seen in Figure \ref{img:op04}
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/op04.png}
\caption{\em Kubectl get deployments}
\label{img:op04}
\end{figure}

Finally in order to launch our memcached pods we need to create our Custom Resource. This file can be seen in Figure \ref{img:op05}.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/op05.png}
\caption{\em Custom Resource}
\label{img:op05}
\end{figure}

Figure \ref{img:op06} shows the creation of the Custom Resource.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/op06.png}
\caption{\em Create Custom Resource }
\label{img:op06}
\end{figure}
\newpage
Now if we run the \textit{get pods} command we can see that we have successfully launched our example pod and our app operator. This reflects the current state of our operator as our memcached pod is essentially a busy box. In Section \ref{sub:updateMem} we will dive in deeper and update and create a working memcached pod.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/op07.png}
\caption{\em Kubectl get pods}
\label{img:op07}
\end{figure}

\subsection{Updating the Memcache Operator}
\label{sub:updateMem}
This section will look at the Operator Controller in more detail. The entire code can be found at Appendix \ref{appendix:memopcon}. In Section \ref{sub:controller} we covered the basis of the Controller in that it watches the resources and triggers a reconcile loop. We outlined some notable functions in particular the Reconcile Function, which can be seen back in Figure \ref{img:p11}. We outlined that the reconcile function reads the current state of the cluster for our created objects and makes changes based on the current state. Currently the reconcile method will only launch a single busy box pod which we verified and used previously to ensure our operator was performing as expected
\\ We will now edit this controller so that the reconcile function will create a Memcached Deployment for every Memcached Custom Resource.
Reconcile reads that state of the cluster for a Memcached object and makes changes based on the state read.
\newpage Figure \ref{img:con1} shows the original function which created a Busy Box, this was called within our Reconcile Function.

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con1.png}
\caption{\em Original Busy Box}
\label{img:con1}
\end{figure}

The following steps need to be completed, we must define our Memcached Deployment, we then need to add logic to our reconcile function to make decisions based on the current state of the cluster.
\\Figure \ref{img:con2} shows the deployment object. As can be seen the rough outline of the object definition follows a normal k8 file. We specify some Type and Object metadata. We outline the number of replicas we want and finally define our pod spec. As can be seen we are using a memcached alpine image.
\\The following code was added to the Reconcile Function, in Figure \ref{img:con3} we want to return our deployment object. Figure \ref{img:con4} is checking if the deployment already exists, if not we will create a new deployment, and then return to the reconcile queue. Figure \ref{img:con5} checks the deployment size, this is used to manage number of replicas within our cluster, and finally Figure \ref{img:con6} we want to update the current memcached status with the pod names.
\\These are typical scenarios and tasks which would normally require human intervention or with the aid of some sort of cron script.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con2.png}
\caption{\em Memcached Deployment object}
\label{img:con2}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con3.png}
\caption{\em Getting Deployment Object}
\label{img:con3}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con4.png}
\caption{\em Checking Deployment Exists}
\label{img:con4}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con5.png}
\caption{\em Checking Deployment Size}
\label{img:con5}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con6.png}
\caption{\em Updating status with pod names}
\label{img:con6}
\end{figure}

\subsection{Running the updated Memcache Operator}
The updated operator was built and run following the same steps as Section \ref{sub:buildop}. Figure \ref{img:con7} shows when we run \textit{get deployments} now we have our operator and our example memcached. As we can see the example memcached has a desired states of 3, current state of 3, up to date of 3 and with 3 available. This is also reflected in Figure \ref{img:con8} where when we ran \textit{get pods} we have our operator pod running and 3 memcached pods running.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con7.png}
\caption{\em Kubectl get deployments}
\label{img:con7}
\end{figure}

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con8.png}
\caption{\em Kubectl get pods}
\label{img:con8}
\end{figure}

In figure \ref{img:con9} we are returning our example memcached pod config, as we can see from the output that it reflects what was set within the operator.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/con9.png}
\caption{\em Kubectl get memcached/example-memcached -o yaml}
\label{img:con9}
\end{figure}

\subsection{Memcache Operator Summary}
A demo of the steps taking to build and launch the Memcached example can be found at Appendix \ref{appendix:opdemo}. 
\\
At face value it was quite intimidating when you see the sheer amount of boilerplate that is generated when you first bootstrap an operator. But when you get down to it, what you need to do in order to develop an operator is quite small. And it is quite easy to see the benefit that adding user logic that would normally require some sort of human intervention.

\section{Operator Lifecycle Manager}
\label{sub:olm}
Throughout Section \ref{sub:practical} we manually built and ran our memcached operator. In this section we will look at the Operator Lifecycle Manager (OLM), it is this tool that handles the install, updating and management of an operators lifecycle. The OLM runs as a Kubernetes extension and lets us use the \textit{kubectl} for all the lifecycle functions with out the need for any additional tools.
\\Unfortunately I could not get the OLM to run as expected, the following documents the steps I took, as Operators are relatively new, there is currently a lack of resources online, with only the bare documentation to go off, I found it difficult to debug the issue.
\\Before proceeding I should explain the overall goal to what I set out to achieve in this section. As we have seen already, Operators are a way we can automate the management of our pods. But how to we manage our Operators, do we need to create an Operator for an Operator? This is where OLM comes in, the OLM manages a Kubernetes resource called CLusterServiceVersion. This CSV is applied to the cluster and through it the OLM manages our Operator. The CSV contains all the metadata needed to update the Operator.
\\So with that I set about adding a CSV to the memecached operator. Figure \ref{img:olm1} shows this, for the full CSV see Appendix \ref{appendix:opsdk}.

\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/olm1.png}
\caption{\em Operator CSV (image cut for brevity)}
\label{img:olm1}
\end{figure}

As per the documentation, Figure \ref{img:olm2} shows the CSV being applied to the cluster.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/olm2.png}
\caption{\em Applying CSV}
\label{img:olm2}
\end{figure}

Figure \ref{img:olm3} shows the deployment of the of the Custom Resource Definition and the Role Based Access Control.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/olm3.png}
\caption{\em Deploying CRD and RBAC}
\label{img:olm3}
\end{figure}

Figure \ref{img:olm4} shows the deployment of our Custom Resource to launch our pods.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/olm4.png}
\caption{\em Deploy CR}
\label{img:olm4}
\end{figure}

Figure \ref{img:olm5} shows our operator and pods and running as expected.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/olm5.png}
\caption{\em Kubectl get pods}
\label{img:olm5}
\end{figure}

\newpage The next step was to apply a new CSV, this contained a different image for our operator. What we should see in Figure \ref{img:olm6} is after our CSV has been deployed, our operator should be updated with the running memcached pods being unaffected. Unfortunately this does not happen. I spent quite some time trying to troubleshoot this problem. Due to a lack of documentation and tutorials online and with me experience with Operators limited to this paper I found it difficult. I suspect that I am missing some requirements needed for OLM as there is none in their documentation. I went to lodge an issue about this but noticed someone else had lodged one before me. As OLM provides a makefile, I was unable to run their make script due to missing requirements, the work around I found for this involved me having to manually apply the OLM manifests to my cluster. I am guessing that I may be missing something here. 
\\ Regardless I feel this section outlines where OLM fits with the Operator Framework.
\begin{figure}[!ht]
\centering
\includegraphics*[width=1\textwidth]{images/olm6.png}
\caption{\em Operator CSV (image cut for brevity)}
\label{img:olm6}
\end{figure}